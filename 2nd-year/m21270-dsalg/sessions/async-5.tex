\lecture{Workshop 7 Async}{19:00}{02/11/23}{Dalin Zhou}

\section*{Hierarchical Data Structures}

\begin{itemize}
  \item A collection of elements, where each element has a unique predecessor and multiple successors
  \item Basic terminology
  \begin{itemize}
    \item Tree - A set of interconnected nodes without a loop
    \item Root node - The first node which all nodes are related to
    \item Branch - The link between two nodes
    \item Subtree - A tree whos root node is within another tree
    \item Leaf - A node with no sucessors
    \item Degree of the node - How many successors it has
    \item Level of the node - How many nodes are between this node and the root
    \item Height or Depth - How many levels are there in the tree
  \end{itemize}
\end{itemize}

\subsection*{Binary Search Tree}

\begin{itemize}
  \item A tree in which every node has two or fewer successors
  \item A binary search tree is a binary tree in which the nodes in the left subtree precede the root and the nodes in the right follow the root
  \item All subtrees are also binary search trees
  \item Since the nodes on the left are smaller, and nodes on the right larger than the root, we can perform a recursive binary search on a binary search tree
  \begin{itemize}
    \item Check if the root is the item
    \item If the item is smaller, recurse on the left subtree
    \item If the item is larger, recurse on the right subtree
    \item Once you get to a node with no successors, the item is not in the tree
  \end{itemize}
  \item To create a binary search tree, you start by inserting the initial item as the root
  \item To insert an item, you must search through the tree by checking if the item is larger or smaller than the node at each level, until you find any empty spot to place it
  \item To delete an item, you must first check how many successors it has
  \begin{itemize}
    \item If the node is a leaf, it can just be removed
    \item If the node has only one successor, the successor can replace the node
    \item If the node has two successors, you take either the right-most item in the left subtree or the left-most item in the right subtree. Since these nodes may have successors, you have to recurse over the subtrees to ensure they are still BSTs
    \item Since there are two options available, the deletion of a node with two sucessors usually has two correct answers so the implementation will need to pick between them
  \end{itemize}
  \item A balanced binary search tree is one in which all leaf nodes are of the same degree
  \begin{itemize}
    \item A balanced tree is important as it allows half of the items in the tree to be disregarded for each comparison
  \end{itemize}
\end{itemize}

\subsection*{Traversal of BSTs}

\begin{itemize}
  \item Depth First Traversal
  \begin{itemize}
    \item Traverses the tree from the root to the most distant child before moving on to the second most distant child, etc
    \item Usually implemented using a stack
    \item Processes leaf by leaf
    \item There are 3 orders in which this can be performed
    \begin{itemize}
      \item Pre-Order - Read the node, then traverse the left subtree, then the right
      \item In-Order - Traverse the left subtree, read the node, then traverse the right
      \item Post-Order - Traverse the left subtree, then the right, then read the node
    \end{itemize}
  \end{itemize}
  \item Breadth First Traversal
  \begin{itemize}
    \item Traverses the tree horizontally from the root to all of it's children, then to their children, etc
    \item Usually implemented using a queue
    \item Processes level by level
    \item Usually outputs each level from left to right
  \end{itemize}
\end{itemize}